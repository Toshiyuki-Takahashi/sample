# 配列
# 複数のデータを格納できる

# ↓配列の定義
users = ["tanaka", "satou", "suzuki", "yamada"]

# ※[]内の数字はインデックス番号で、左から0,1,2・・・と順番で指定して取り出す。
puts users[1]

# ※↑よりよく使うのは「繰り返し分＆配列」
users.each do |user|
  puts "#{user}さん"
end
# 「users」は複数のデータが配列に格納されているから「s」複数系にしている。
# 　eachは1つ１つのデータを変数に格納するので単数系の「user」をつかう。
# この形はraisでよく使う形なので覚えておく。
# 上記は
# "tanaka"を|user|に格納して処理を行う、
# "satou"を|user|に格納して処理を行う、
# "suzuki"を|user|に格納して処理を行う、
# "yamada"を|user|に格納して処理を行う、
# という処理を繰り返す式。

puts "----------------------------"

# each.with_indexというものもある。
# インデックス番号と一緒に繰り返し文をやってくれるもの。
# |user|はそれぞれのユーザーが格納されるところ。
# |i|はインデックス番号が格納されるところ。
# 　┗処理のされ方は、1回カウントすることに処理されていく。
# 　→0〜順番にカウントされていく。

users.each.with_index do |user, i|
  puts "会員No.#{i}#{user}さん"
end

# 【アプトプット】
# 会員No.0tanakaさん
# 会員No.1satouさん
# 会員No.2suzukiさん
# 会員No.3yamadaさん
puts "----------------------------"

# each文の省略形
# 現場でもよく出てくるので、読めるようになっておくと良い。

users.each { |user| puts "#{user}さん"}

# 【アウトプット】
# tanakaさん
# satouさん
# suzukiさん
# yamadaさん

puts "----------------------------"
# ただ、「０」から会員番号が始まるのはおかしいから「１」から始める処理を
# 記述する必要がある。
# ↓indexの横に(1)と記述してあげることで、1開始で指定することが可能となる。

users.each.with_index(1) do |user, i|
  puts "会員No.#{i}#{user}さん"
end

# 【アウトプット】
# 会員No.1tanakaさん
# 会員No.2satouさん
# 会員No.3suzukiさん
# 会員No.4yamadaさん　

puts "----------------------------"

# users.joinという便利な配列もある。
# ┗「◯◯さん」と「◯◯さん」と「◯◯さん」と配列したい時に
# 　要素の間だけ表示するもの。
# 　→要素間に何かを入れたい時の配列のさせかた。

puts users.join("さんと、")

# 【アウトプット】
# tanakaさんと、satouさんと、suzukiさんと、yamada
